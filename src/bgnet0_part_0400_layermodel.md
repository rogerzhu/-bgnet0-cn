# 分层网络模型

在正式介绍之前，首先需要阐述几个概念: 

* **IP 地址** -- 传统上，在因特网上使用一个4字节数唯一的标示你的计算机。数字之前用点号隔开，比如:`198.51.100.99`。这些被称之为IP协议版本4（"IPv4"）地址。通常，在没有任何其他版本标识符的情况下，使用“v4”作为默认版本。

* **端口** -- 程序通过编号为0-65535端口进行通信，并且它们与TCP或UDP协议相关联。由于多个程序可以在同一个IP地址上运行，端口提供了一种唯一识别网络上这些程序的方法。举个例子，一个常见的应用就是网站服务一般都是在80端口上监听连接。对于服务端程序，发布端口号对于客户端非常重要，因为客户端程序需要知道通过什么端口才能连接上服务端程序。而客户端一般都是让操作系统自动选择一个还未使用的端口号，因为没有程序需要知道怎么能主动连上客户端程序。在一个URL中，端口号一般被置于冒号后面。比如我们想在端口`3490`连接`example.com` ，那么URL写做：`http://example.com:3490/foo.html` 。在计算机中，小于1024的端口号只有根账户/管理员账户才能有权限绑定（但是可以随意连接）。

* **TCP** -- 传输控制协议，负责提供可靠，有序的数据传输。从更高的层次来看，使得分组交换网络看起来更像电路交换网络。TCP使用端口号来标示发送和接收数据。TCP协议于1974年被发明出来并且现在被广泛使用于计算机网络。在套接字API中，TCP套接字被称之为 _流套接字_。

* **UDP** -- TCP的兄弟协议，不过更加轻量级。该协议不会保证数据一定会被送达，或者按需到达以及到达的数据不重复。如果数据到达，那么数据本身是没有错误的，这就是接收端能获得所有信息。在套接字API中，UDP套接字被称之为 _数据报套接字_。

* **IPv6 地址** -- 四个字节已经不足以标示唯一一个地址了，所以IP协议版本6将标示地址的大小扩展到16个字节。IPv6地址看起来是这样`::1` 或者`2001:db8::8a2e:370:7334`，甚至更长。

* **NAT** -- 网络地址转换。这是一种方法，可以让用户拥有私有的子网地址，这些子网地址可以不是全局唯一的，而该方法可以提供一种转换的方式将全局唯一的地址转换成内部地址，这样可以让数据路由到合适的地址。私有地址常常以`192.168.x.x`或者`10.x.x.x`开头。

* **路由器** -- 一种在报文分组网络中转发数据报的特殊的网络设备。它检查目的IP地址，以确定哪条路由可以使数据包更接近的发送到目标地址。

* **IP** -- 互联网协议。它负责通过IP地址识别计算机，并使用这些地址通过各种路由器将数据发送到接收方。

* **LAN** -- 局域网。这是一种所有计算机都直连的网络，中间不经过路由器。

* **网络接口** -- 计算机上的物理网络设备。一台计算机上可能有很多网络接口。你的电脑上大概率有两个: 一个有线网络接口和一个无线网络接口。一个路由器可能拥有很多网络接口，如此才能把数据报发送到不同的目的地地址。但是你的家用路由器可能只有两个接口: 一个用来接入局域网，其它用来接出到因特网上的其它部分。每个接口都有一个独立的IP和MAC地址。操作系统会命名本地计算机上的接口，它们可能叫`wlan0` 或者 `eth2` ，抑或是其它名称。这些起名方式取决于硬件和操作系统。

* **报头** -- 一些加在特定协议之前的数据。报头包含适合该协议的信息，譬如，TCP报头将包括一些错误检测和纠正信息以及源和目的端口号，IP报头包括源IP地址和目的IP地址，以太网报头包括源MAC地址和目标MAC地址。HTTP响应报头中包括数据长度、修改日期以及请求是否成功等信息。 在数据前加一个报头就好比在传统邮件外面包一个信封，或者在信封外面再继续加上信封。
当数据在网络中传输时，额外的报头会不断的被添加和移除。通常，最顶端（最外端）的报头不断的被移除和添加是一个很普遍的操作，就像一个堆栈（不过一些软件和硬件会去取更深的报头信息）。
  **网络适配器** -- 通常也被称为“网卡”，你计算机上负责处理网络事宜的硬件。
  **MAC 地址** -- 以太网接口都有MAC地址，形式为`aa:bb:cc:dd:ee:ff`，是由一些随机的一字节的数字组成。MAC地址一般都是6字节，并且在局域网中必须是唯一的。当一个网卡被组装好，就会赋予它一个MAC地址，这个MAC地址通常情况下会伴随其一生。

## 分层网络模型

当你在互联网上发送数据时，数据会被 _封装_ 在不同的协议层。概念上的分层网络模型的各层对应于各种类型的协议。这些协议负责不同的指责，比如，描述数据，保证数据完整性，路由数据，本地传达等等。所以这是一个先有鸡还是先有蛋的问题，因为我们不能只讨论其中一些而不讨论另一些。在深入了解这些协议之前，最好是先了解下各个层次的报头。

## 分组协议数据实例

让我来看看当发送一个HTTP请求时发生了什么。

1. 浏览器构造了类似如下的一个HTTP请求：
   ``` {.default}
   GET / HTTP/1.1
   Host: example.com
   Connection: close

   ```
   而这就是浏览器关心的所有内容，它不关心IP协议是如何路由数据或者TCP协议是如何保证数据完整性的，更不会关心以太网上的内容。 它只会说“把这些数据发送到指定计算机的80端口”。

2. 然后，操作系统开始接管，并且说:“收到，你要求我通过面向流的套接字发送此数据，我将使用TCP协议来完成此操作，并确保所有数据完整有序地到达。”
   所以，操作系统拿到上一步的HTTP数据数据之后，将其封装到一个TCP报头中，在该报头中会包含一个端口号。

3. 接着，操作系统说:“你想把它发送到IP地址是198.51.100.2的远端计算机，所以我们将使用IP协议来做到这一点。”
   为了达到这一点，操作系统将上一步所产生的所有TCP-HTTP数据都放到一个IP报头中。所以，现在操作系统将要发送的数据是: IP-TCP-HTTP.

4. 之后，操作系统会看一眼它的路由表并且判断下一步将数据发送到哪里，也许很便利，终点就是局域网上的一个网站服务器。但是更多的情况下，终点会是其它的某
   个地方，所以，通常情况下，数据会被发送到你房子里的一个为了将数据转发到更大因特网的一个路由器上。无论哪种情况，操作系统要么会把数据发送到局域网的一个服务器上，或者是一个依然在局域网内的出口路由器上。所以，言而总之，数据报会被发送到局域网上的一台计算机中。
   局域网中的每台计算机都有一个以太网地址（也就是所谓的 _MAC 地址_ -- 代表着“介质访问控制”），所以，发送端的操作系统会查找下一跳目的IP地址对应的MAC地址，它可能是一个本地的网站服务器，或者是一个出口路由器（这个过程通过查询一个叫做 _ARP 缓存_ 的表，我们将在后面的章节详细介绍）。
   到这里，操作系统会将上面三步所组成的整个IP-TCP-HTTP数据报包装到一个以太网报头中，所以这时候整个发送的内容变成了Ethernet-IP-TCP-HTTP。对于网页的请求依然在其中，只不过被深深的藏在了各层的协议中！

5. 最终，所有的数据都会从线路中被发送出去（即使是WiFi，我们依然用“线路”）。

   对应远端MAC地址的计算机，在线上仔细的聆听对应的以太网数据包，然后将其读入（以太网数据包被称之为 _以太网帧_）。 

   接着，该端操作系统会剥离以太网数据头，暴露出在它之下的IP数据头，用以查看目的地IP地址。 

6. 如果正在被检查的计算机是一台拥有IP数据包所携带的IP地址的话，对应的操作系统会剥离IP数据头并进行更深层次的查看（如果该服务器不拥有对应的IP地址，
   那么出现了一些问题，该数据包将会被丢弃）。 

7. 接下来，操作系统会查看TCP数据头，并且进行所有TCP所需的计算以保证接收端的数据没有损坏。如果数据损坏，该服务器会回复“TCP魔法咒语”，告诉对端：
   “喂，我需要你重新发送下刚才的数据！”。 注意，无论是网页浏览器或者服务器本身都完全不知道上述的TCP转换，这一切都是发生在幕后。就它所能看到的，数据只是奇迹般地完整有序地到达。 核心原因就是，这些部件都位于计算机网络的更高层次中，它们从来不用担心路由过程或者任何相关的事宜。低层次的程序会完全的负责这一切。

8.  如果在TCP这一层一切都完好，这一层协议的报头就会被剥离，这时操作系统将会看到剩下的HTTP数据。它将唤醒一直在等待的相应的进程（网站服务器程序），并且将HTTP数据喂给它。 
   
但是，如果目标以太网地址是一个中间的路由器会发生什么呢？ 

1. 路由器会如同之前描述的过程一样，剥离掉以太网帧。 

2. 接着，路由器开始查看目的地IP地址，路由器会查询其路由表，然后决定使用哪个接口发送数据包。 

3. 随后，路由器根据上一步得到接口信息，将整个的IP层的数据包裹在新的以太网帧中，发送给网络中的下一跳路由器。（这里以太网只是一种底层协议，还有其它很多比如光纤中使用的通信协议。这就是分层的美妙之处--用户可以在传输的中途切换协议，上面的HTTP数据完全不知道发生了任何这样的事情。）

## The Internet Layer Model 

让我们从一个简单的将这种传输从上到下划分为不同的层次的模型开始。(请注意，下面列出的协议列表远非详尽无遗。)。

<!-- 图示: 因特网分层模型 -->
|层级|职责|协议举例|
|:-:|-|-|
|应用层|结构化的应用层数据|HTTP, FTP, TFTP, Telnet, SSH, SMTP, POP, IMAP|
|传输层|数据完整性，数据分割和组装|TCP, UDP|
|网络层|路由|IP, IPv6, ICMP|
|链路层|物理设备，线路上的电信号|Ethernet, PPP, token ring|

下面，你将会看到在这个模型中，不同的协议在各个层级上是怎么履行各自职责的。另一种思考方式是，所有实现HTTP、FTP或SMTP的程序都可以使用TCP或UDP传输数据。(通常，所有用户编写的套接字程序和应用都会工作在应用层。)。所有使用TCP或UDP传输的数据都可以使用IP或IPv6进行路由。

所有使用IP或IPv6进行路由进行路由的数据包都可以通过以太网或者PPP等协议在网线上传输。一个数据包在真正的在网线上传输之前，下一层协议都会在上一层协议数据之前加入对应的数据包。这种模型足够支撑数据在因特网上传输。有一句名言:尽量简单，但是不能过度简单。

不过网络世界上不止一种因特网，所以有一些其它人定义出来的更加通用的网络模型: OSI 网络模型。

## ISO OSI网络分层模型

如果你正在考某种证书或者远远不想只成为一个普通程序员，那么了解这一部分知识益处良多。

因特网分层模型是ISO定义的OSI网络模型的一种特殊而又具体的实现（ISO OSI这里形成了回文，一个神奇点）。OSI ISO模型全称为国际标准化组织定义的开放系统互连模型。我知道“ISO”不是“国际标准化组织”的直接英文缩写，但我没有足够的全球政治影响力来改变这一点。

回到现实中来，OSI模型和因特网模型很相似，只不过粒度更细。因特网模型可以一对多的映射到OSI模型，如下所示：
<!-- 图示: OSI模型到因特网模型映射-->
|ISO OSI模型层级|因特网模型层级|
|:-:|:-:|
|应用层|应用层|
|表示层|应用层|
|会话层|应用层|
|传输层|传输层|
|网络层|网络层|
|数据链路层|链路层|
|物理层|链路层|

如果我们看一下OSI模型，我们可以看到存在于各个层级中的不同协议，类似于我们在上面看到的因特网模型。

<!-- 图示: ISO OSI网络模型-->
|ISO OSI 层级|职责|示例协议|
|:-:|-|-|
|应用层|结构化的应用化数据|HTTP, FTP, TFTP, Telnet, SMTP, POP, IMAP|
|表示层|编码传输，加密，压缩|MIME, SSL/TLS, XDR|
|会话层|挂起，终止，重启两台计算机之前的会话|Sockets, TCP|
|传输层|数据完整性，数据分割和组装|TCP, UDP|
|网络层|路由|IP IPv6, ICMP|
|数据链路层|将数据装入帧中|Ethernet, PPP, SLIP|
|物理层|物理器件，线路上的信号|Ethernet physical layer, DSL, ISDN|

后续的章节中，我们将专注于因特网模型，因为它对于你所想要的百分之九十九的网络编程都是适用的。不过，如果你想面试一个网络编程相关的岗位，那么OSI模型也是你所需要知晓的。

## 思考题

* 当路由器看到一个IP地址时，它是怎么知道如何转发至下一跳的？
  
* 如果每台电脑都只能有一个不重复的IP地址，4字节的IPv4地址可以表示多少台计算机？

* 如果每台电脑都只能有一个不重复的IP地址，16字节的IPv6地址可以表示多少台计算机？

* 给统计爱好者的附加题:赢得超级乐透头奖的几率约为3亿比1,那么随机挑选我预先选择的16字节(128位)数字的几率是多少?

* 想一想为什么在分层模型中，IP协议是在TCP协议之上，也就是为什么TCP的报头在IP报头的前面，而不是反过来？

* UDP是不可靠协议而TCP是可靠协议，那么有什么场景下会使用UDP协议？

